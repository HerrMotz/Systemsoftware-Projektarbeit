
\documentclass[runningheads]{llncs}
%
\usepackage[T1]{fontenc}
% T1 fonts will be used to generate the final print and online PDFs,
% so please use T1 fonts in your manuscript whenever possible.
% Other font encodings may result in incorrect characters.
%
\usepackage{graphicx}
% Used for displaying a sample figure. If possible, figure files should
% be included in EPS format.
%
% If you use the hyperref package, please uncomment the following two lines
% to display URLs in blue roman font according to Springer's eBook style:
%\usepackage{color}
%\renewcommand\UrlFont{\color{blue}\rmfamily}
%

% Daniel Motz's packages
\usepackage{amsfonts}
\usepackage{mathtools}
\DeclarePairedDelimiter\ceil{\lceil}{\rceil}
\DeclarePairedDelimiter\floor{\lfloor}{\rfloor}

\usepackage{minted}
% END Daniel Motz's packages

\begin{document}
%
\title{An Implementation of Buddy Memory Allocation}
%
%\titlerunning{Abbreviated paper title}
% If the paper title is too long for the running head, you can set
% an abbreviated paper title here
%
\author{Friedrich Answin Daniel Motz}
%
\authorrunning{D. Motz}
% First names are abbreviated in the running head.
% If there are more than two authors, 'et al.' is used.
%
\institute{FMI, Friedrich-Schiller-University Jena, Jena, Germany\\
Project work for Systemsoftware\\
\email{daniel.motz@uni-jena.de}
}
%
\maketitle              % typeset the header of the contribution
%
\begin{abstract}
Please note that the first paragraph of a section or subsection is
not indented. The first paragraph that follows a table, figure,
equation etc. does not need an indent, either.

\keywords{First keyword  \and Second keyword \and Another keyword.}
\end{abstract}
%
%
%
\section{Considerations}
\subsection{Programme requirements}
Buddy memory allocation is a memory allocation algorithm. To serve a memory
allocation request of size $r$, we divide our pool size 
$p \in \{2^i\}, i \in \bbbn_0$ into blocks of 
an arbitrary but fixed minimum size $s$. So, there are $n$ blocks in total,
where $n = \frac{p}{s}$.
For our request, we may allocate any number of our $n$ blocks, which means,
that any consecutive allocated memory will have a size of a power of 2.
Our request size $r$ may not be a power of 2, which requires us to allocate 
the next largest power of 2, causing internal fragmentation of size $f$, where

\[ f = 2^{\ceil{\text{ld}(r)}} - r \]

We would like to reduce internal fragmentation, which will be dealt with in a 
later chapter. // TODO add link to chapter
One approach may be to initially, have only one block spanning the pool's size.
To serve the request of size $r$ the search for free space recursively divides
free space by two until a block that is big enough to accommodate the request 
is found~\cite{ostep}.

\subsection{Using binary trees} The above described approach to Buddy allocation
will lead to something very similar to a simple free list.
However, the property that any block may only be divided in exactly two, with
half of the parent's block size each, gives us the opportunity to use binary
trees instead.

\subsubsection{Which properties does this bin-tree need?}
A proper binary tree is necessary, as a block may not be divided into only one
block. So, there are always exactly $0$ or $2$ children to a parent.

\subsubsection{Allocating memory}
It may seem very simple: search for a block which fits the request size $r$
with minimum fragmentation $f$. We prefer finding a lonely buddy over halving
a larger block. So, a node should, apart from storing a reference to his parent
and his children, also know whether he is allocated or free. Because we always
look for a lonely buddy when allocating, it makes sense to add a third state:
partly allocated. This property may be given to parents with a lonely child.

\begin{problem}
    How should the tree be managed?

    An important sub-question is, where the information about the nodes should
    be stored. We could store the allocation status in 2 bits within a header
    of each block. But does this make much sense?

    For the scope of this project work I have decided to go the hard route and
    store it inside of the managed memory. It will be part of the header.

    Second and last sub-question: Should the tree be initialised spanning
    all of the address space and create all nodes preemptively?
    
    Except for a slight simplification of the allocation and free algorithm,
    there are no groundbreaking advantages. Simultaneously, the detriments in
    performance are huge. Bigger pool sizes would cause us to make huge 
    amounts of nodes, causing initialisation to be expensive. Secondly,
    these nodes need to be stored somewhere and we do not need all
    of them anyway (otherwise we could store data in an array with each
    element of the same size). In conclusion, it would defeat the sense of
    managing the memory. We therefore create more nodes, when we need them.
\end{problem}



\subsubsection{Freeing space}
Freeing space is a question of finding the node to delete and cleaning up
afterwards. If an empty buddy was deleted, the parent's state should be changed
from \textbf{partly allocated} to \textbf{free}.

Later on we will discuss, whether it makes sense to mark a parent partly
allocated, when a child is partly allocated. Should this be the case, a 
tree is the perfect data structure. We go from a node to its parent and 
mark it appropriately.

\section{Implementation}

\subsection{Considerations}

A node in a tree will be, for now, defined as follows:

\begin{minted}{C}
#define FREE 0
#define ALLC 1
typedef struct node_t {
    unsigned char allocation;
    struct node_t *parent, *left, *right;
} node_t;
\end{minted}

\subsection{Finding free space}

The search starts at the tree's root and looks for a free node with an allocated
brother of the right size. The level of a node is defined as it's distance from 
the root.

Before any calculations may be made, some boundaries need to be set.
Somehow, a minimum allocation size needs to be chosen. Depending on the
workload a different minimum size makes sense. A very small lower limit
leads to very small allocation sizes. A very big limit leads to abundant
fragmentation, should most requests be small. The maximum allocation size
is equal to our pool size.

To determine the right level for the allocation, the search starts at the
bottom. It makes more sense with a while loop, because the goal is to 
find the next largest block that fits the request.

\begin{minted}{C}
#define MIN_SIZE_LD 8 // 2^8 Byte = 256 Byte
#define MIN_SIZE (size_t) 1 << MIN_SIZE_LD
#define MAX_SIZE_LD 28 // 2^28 Byte = 256 MiB
#define MAX_SIZE (size_t) 1 << MAX_SIZE_LD
#define MAX_LEVELS MAX_SIZE_LD - MAX_SIZE_LD + 1
size_t get_request_level(size_t request_size) {
    size_t size = MIN_SIZE;
    size_t level = MAX_LEVELS;
    while (size < request_size) {
        size <<= 1; // double until it fits the req. size
        level--;
    }
    return level;
}
\end{minted}

It is defined, that this is the right level. Choosing it lower does not fit 
the request and bigger leads to unnecessary fragmentation.

Our data structure tree has one big disadvantage: we cannot search efficiently
through all nodes of one level. However, a doubly-linked list on each level 
would be perfect. A redefinition of the node type is called for. Also,
to directly access a level, an array is introduced, as well as a level
limit counter, to track how many levels are in use.

\begin{minted}{C}
typedef struct node_t {
    unsigned char allocation;
    struct node_t *parent, *left, *right,
                  *prev, *next; // +
} node_t;

node_t levels[MAX_LEVELS];
int level_limit;
\end{minted}

This node\_t structure looks ridiculous, as it has 6 properties in total - 5 of
which are pointers to other nodes. Since the goal is to implement a memory
allocator and the nodes should be stored in the managed memory, one could
simply go ahead and calculate the reference to parents and children with
pointer arithmetic. A tree may be represented as an array with 
indices~\cite{binary_tree_index_properties}. Therefore, with a base pointer
as index 0 and offset calculations a memory address may be derived from an 
index and vice versa. Hence, storing nodes at the correct memory address,
enable us to determine all relationships.

Lastly, previously an unsigned char of 8 bit size was planned to store 
allocation status - but 2 bit are sufficient. This leaves a stripped node\_t
of 16 Bytes one may be rightfully content with.

\begin{minted}{C}
typedef struct node_t {
    struct node_t *prev, *next;
} node_t;
\end{minted}

Just like in a free list, these nodes in doubly-linked lists per level will 
represent free spaces, which may be wholly allocated or subdivided.
For operations on these lists, there are \textbf{b\_list\_*} functions in 
\texttt{list.h}.

\subsubsection{Acknowledgements} Please place your acknowledgments at
the end of the paper, preceded by an unnumbered run-in heading (i.e.
3rd-level heading).

%
% ---- Bibliography ----
%
\bibliographystyle{splncs04}
 
\newpage

\begin{thebibliography}{8}

\bibitem{ostep}
Arpaci-Dusseau, R. H., Arpaci-Dusseau, A. C., : Operating Systems Three Easy Pieces. Version 0.80. Arpaci-Dusseau Books, Inc.,
University of Wisconsin-Madison (2014)

\bibitem{evanw_buddy_malloc}
E. Wallace. Buddy Memory Allocator, \url{https://github.com/evanw/buddy-malloc}. Last accessed 25.
March 2022

\bibitem{binary_tree_index_properties}
C. Riesbeck. EECS 311: Trees, \url{https://courses.cs.northwestern.edu/311/html/tree-notes.html}. Last accessed 10. March 2022

\bibitem{ref_article1}
Author, F.: Article title. Journal \textbf{2}(5), 99--110 (2016)

\bibitem{ref_lncs1}
Author, F., Author, S.: Title of a proceedings paper. In: Editor,
F., Editor, S. (eds.) CONFERENCE 2016, LNCS, vol. 9999, pp. 1--13.
Springer, Heidelberg (2016). \doi{10.10007/1234567890}

\bibitem{ref_proc1}
Author, A.-B.: Contribution title. In: 9th International Proceedings
on Proceedings, pp. 1--2. Publisher, Location (2010)
\end{thebibliography}
\end{document}
